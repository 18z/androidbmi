#summary 活動的生命週期
#labels tw, lifecycle

{{{
維護一個 Activity 的生命週期非常重要，因為 Activity 隨時會被系統回收掉。
}}}

== 生命週期 ==

作者在初級章節中一直努力地傳達給讀者：編寫 Android 平台的基本應用程式，跟編寫桌面應用程式的難度，兩者並沒什麼不同。甚至因為 Android 平台擁有免費、跨平台的開發工具，使得 Android 平台應用程式的開發更為單純。

但是請別忘了，Android 平台也是個手機作業系統。撇掉其他功能不談，手機的特性就是應該能隨時在未完成目前動作的時候，離開正在使用的功能，切換到接電話、接收簡訊模式...而且在接完電話回來應用程式時，還希望能看到一樣的內容。

現在使用者使用智慧型手機，大多已習慣使用多工(Multi-Task)的作業系統(如 Windows Mobile)，可以在用手機聽音樂的同時，也執行其他多個程式。同時執行多個程式有它的明顯好處，但是也有它的嚴重的缺點。每多執行一個應用程式，就會多耗費一些系統記憶體。而手機裡的記憶體是相當有限的。當同時執行的程式過多，或是關閉的程式沒有正確釋放掉記憶體，執行系統時就會覺得越來越慢，甚至不穩定。

為了解決這個問題， Android 引入了一個新的機制 -- 生命週期 (Life Cycle)

=== 行程 ===

應用程式（一個個 Activity）執行的狀態稱為行程(process)。在 Android 作業系統中，每個應用程式都是一個行程。Android 系統平台(準確的說是 Dalvik 虛擬機)會維護一個唯一的 Activity 歷史記錄堆疊，並從旁觀察每個應用程式行程。系統平台會依照系統的記憶體狀況，與 Activity 的使用狀態，來管理記憶體的使用。

Activity 類別除了負責運行程式流程，與操作介面元件之外，最重要的，就是它提供了開發者控制行程生命週期的函式。我們已經相當習慣在 OnCreate (建立行程時的行為)函式中，加入我們對這個 Activity 執行流程的控制。在前面遇到的範例中，我們並不需要對除了 OnCreate 之外的行為做出改變。不過理解行程的生命週期，將為我們繼續深入 Android 開發打下基礎。

=== 為什麼要了解生命週期 ===

Android 應用程式的生命週期是由 Android 系統平台 (準確的說是虛擬機) 進行管理，而不是由應用程式直接控制。

通常，每一個應用程式（入口一般會是一個 Activity 的 onCreate 方法），都會佔據一個行程(Process)。當系統記憶體即將不足的時候，會依照優先級自動進行行程(process)的回收。不管是使用者或開發者，都無法確定的應用程式何時會被回收。

一個 Activity 類別除了 OnCreate 函式之外，還預先定義了 OnFreeze (凍結行程時的行為)、OnPause(暫停行程時的行為)、OnResume(繼續行程時的行為)等等的基本行為，當從一個 Activity 切換到另一個 Activity 的時候，原本的 Activity 將經過一連串的狀態改變。開發者可以在程式中添加一些各狀態相對應的流程，每次 Activity 改變狀態時，就會執行相對應的流程。

要讓使用者有好的使用經驗，Activity 需要在各個週期點上負責保管狀態、恢復狀態、傳送資料等工作。

== Activity 的狀態 ==

Android 的虛擬機(VM)是使用堆疊 (Stack based) 管理。主要有四種狀態：

  * Active (活動)
  * Paused (暫停)
  * Stopped (停止)
  * Dead (已回收或未啟動)

=== Active (活動) ===

「Active」狀態是使用者啟動應用程式或 Activity 後，Activity 運行中的狀態。

在 Android 平台上，同一個時刻只會有一個 Activity 處於活動(Active)或運行(Running)狀態。其他的 Activity 都處於未啟動(Dead)、停止(Stopped)、或是暫停(Pause)的狀態。

=== Paused (暫停) ===

「Paused」狀態是當 Activity 暫時暗下來，退到背景畫面的狀態。

當我們使用Toast、AlertDialog、或是電話來了時，都會讓原本運行的 Activity 退到背景畫面。新出現的Toast、AlertDialog等介面元件蓋住了原來的 Activity 畫面。Activity 處在「Paused」狀態時，使用者無法與原 Activity 互動。

=== Stopped (停止) ===

「Stopped」狀態是有其他 Activity 正在執行，而這個 Activity 已經離開螢幕，不再動作的狀態。

透過長按「Home」鈕，可以叫出所有處於「Stopped」狀態的應用程式列表。

在「Stopped」狀態的 Activity，還可以透過「Notification」來喚醒。「Notification」會在後面章節中解說。

=== Dead (已回收或未啟動) ===

「Dead」狀態是 Activity 尚未被啟動、已經被手動終止，或已經被系統回收的狀態。

要手動終止 Activity，可以在程式中呼叫「finish」函式。我們在[AndroidMenu 加入選單]一章中已經提到過了。

如果是被系統回收，可能是因為記憶體不足了，所以系統根據記憶體不足時的回收規則，將處於「Stopped」狀態的 Activity 所佔用的記憶體回收。

== 記憶體不足時的行為 ==

記憶體不足時，Dalvak 虛擬機會根據其記憶體回收規則來回收記憶體：

  # 先清理沒有其他 Activity 或 Service/Intent Receiver 相關的空行程(empty process)。
  # 處於「Stopped」狀態的背景(background) Activity。 根據 LRU 列表排序。被回收掉的 Activity 一旦又重新被呼叫時，會再次呼叫 Activity 的 onCreate 函式。
  # service process
  # 可見的 Activity/行程
  # 前景(foreground) 的 Activity

當系統缺記憶體缺到開始砍「4. 可見的 Activity/行程」時，大概我們換機子的時間也早該到啦！

== Activity 運作流程 ==

{{{
編寫中
}}}

= 參考資料 =

  * Activity Cycle http://www.anddev.org/images/android/activity_lifecycle.png

= 結語 =

這幾章講解了如何撰寫介面、如何撰寫程式碼、如何新增選單，與應用程式如何在多個 Activity 之間切換。了解了這些內容，已足夠我們寫出一般的 Android 應用程式。

Android 是個完整的平台，還有諸多內容值得研究。例如儲存資料、共享內容、網路、瀏覽器、地圖服務、相機、3D、遊戲、通話與簡訊等等進階的主題。

希望讀者能以此小書出發，開發出自己的 Android 程式。

請別吝於留言反應，寫出自己的讀後感言、提出覺得不解的地方、分享自己的經驗。這些都可以協助你更好的學習 Android。如果覺得有那些小地方漏講，也請您直接在該章後加上您的建議。協助其他人，就是協助當初的自己。

== 版權宣告 ==

誠摯地提醒您，本書仍在持續地完善中。本書的文字、圖片、程式碼皆不歡迎轉載，也不可使用於商業用途。
但歡迎您將本書網址 http://code.google.com/p/androidbmi/wiki/IntroAndroid 分享到各網站。

== 填寫讀後問卷 ==

如果您花時間讀了本書，請幫忙填寫只有4題的[http://spreadsheets.google.com/viewform?key=pftJzzqckPIll5elBVuuDWQ 讀後問卷]，以協助改善本書。

< [AndroidDebug 記錄與偵錯 (Log)]  | [DiveIntoAndroid 回目錄] | [AndroidPreference 儲存資訊] >